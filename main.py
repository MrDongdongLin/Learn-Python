import cv2
import numpy as np
import random
import math
from PIL import Image
from matplotlib import pyplot as plt

import init
# import chaoticMap as cm

def Encrypt(A, D, C0, v):
	m, n = np.shape(A)
	p1, p2 = np.shape(C0)
	C = np.zeros((m, n))
	for i in xrange(0, r1):
		for j in xrange(0, r2):
			if i+j == 0:
				C[0:p1,0:p2] = A[0:p1,0:p2] + v * D[0:p1,0:p2] + C0
			elif i+j == r1+r2-2:
				C[i*p1:m,j*p2:n] = A[i*p1:m,j*p2:n] + C[i*p1:m,(j-1)*p2:n-p2]
			elif j == 0:
				C[i*p1:(i+1)*p1,j*p2:(j+1)*p2] = A[i*p1:(i+1)*p1,j*p2:(j+1)*p2] + v * D[i*p1:(i+1)*p1,j*p2:(j+1)*p2] + C[(i-1)*p1:i*p1,(r2-1)*p2:r2*p2]
			else:
				C[i*p1:(i+1)*p1,j*p2:(j+1)*p2] = A[i*p1:(i+1)*p1,j*p2:(j+1)*p2] + v * D[i*p1:(i+1)*p1,j*p2:(j+1)*p2] + C[i*p1:(i+1)*p1,(j-1)*p2:j*p2]
	return C

def Decrypt(C, D, C0, v):
	m, n = np.shape(C)
	p1, p2 = np.shape(C0)
	A = np.zeros((m, n))
	for i in xrange(0, r1):
		for j in xrange(0, r2):
			if i+j == 0:
				A[0:p1,0:p2] = C[0:p1,0:p2] - v * D[0:p1,0:p2] - C0
			elif i+j == r1+r2-2:
				A[i*p1:m,j*p2:n] = C[i*p1:m,j*p2:n] - C[i*p1:m,(j-1)*p2:n-p2]
			elif j == 0:
				A[i*p1:(i+1)*p1,j*p2:(j+1)*p2] = C[i*p1:(i+1)*p1,j*p2:(j+1)*p2] - v * D[i*p1:(i+1)*p1,j*p2:(j+1)*p2] - C[(i-1)*p1:i*p1,(r2-1)*p2:r2*p2]
			else:
				A[i*p1:(i+1)*p1,j*p2:(j+1)*p2] = C[i*p1:(i+1)*p1,j*p2:(j+1)*p2] - v * D[i*p1:(i+1)*p1,j*p2:(j+1)*p2] - C[i*p1:(i+1)*p1,(j-1)*p2:j*p2]
	return A

if __name__ == '__main__':
	# Control parameters (a, b, w1, w2, mu, mu1, mu2), plain image (img), block size (p1,p2).
	a, b, w1, w2, mu, mu1, mu2 = 1, 1, 50, 50, 3.999, 20, 15
	img = cv2.imread('Lena.bmp')
	AMatrix, _, _ = cv2.split(img)
	q1, q2 = init.BlockIndex(w1, w2)
	p1, p2 = init.bsize[q1][q2]
	M, N, dim = img.shape
	r1, r2 = M/p1, N/p2

	# Psedorandom sequence: n >= max{M*N+r, p1*p2+mu1<256}, sx = {x0,x1,...,xn}, sy = {y0,y1,...,yn}, sx_ = {x_0,x_1,...,x_n}.
	n = M*N+256
	x0, y0, xb0 = init.InitialCondition()
	sx, sy, sxb = init.KeyGen(a, b, mu, x0, y0, xb0, n)
	# Before applying the chaotic sequence generated by iterating the logistic map onto a plain-image, we perform a conversion
	sx_c = map(np.uint8, map(lambda s: math.floor(s*math.pow(10,14))%256, sx))
	sy_c = map(np.uint8, map(lambda s: math.floor(s*math.pow(10,14))%256, sy))
	sxb_c = map(np.uint8, map(lambda s: math.floor(s*math.pow(10,14))%256, sxb))

	# Control parameter r and v
	r, v = sxb_c[mu1], sxb_c[mu2]
	sDMatrix = []
	for i in xrange(0, M*N/2):
		sDMatrix.append(sx_c[r+1+i])
		sDMatrix.append(sy_c[r+1+i])

	# Convert image AMatrix and psedorandom matrix DMatrix to array A and D, respectively.
	DMatrix = np.array(sDMatrix).reshape(M, N)
	D = np.mat(DMatrix)
	A = np.mat(AMatrix)
	# Generate C0
	indx, indy = [(r1-1)*p1-1,r1*p1-1], [(r2-1)*p2-1,r2*p2-1]
	mu3 = sum(map(sum, A[np.ix_(indx, indy)]))%256+1
	sC0 = []
	for i in xrange(0, p1*p2):
		sC0.append(sxb_c[i])
	C0 = np.mat(np.array(sC0).reshape(p1, p2))

	C = Encrypt(A, D, C0, v) % 256
	AA = Decrypt(C, D, C0, v) % 256

	# show images
	plt.subplot(131)
	plt.imshow(A, 'gray')
	plt.title("Lena")

	plt.subplot(132)
	plt.imshow(C, 'gray')
	plt.title("Lena_e")

	plt.subplot(133)
	plt.imshow(AA, 'gray')
	plt.title("Lena_d")

	plt.show()
